#!/bin/bash
#
# Back up the files listed in the $C_FILES_TO_BACK_UP array.
#
########################################################################################
####[ Global Variables ]################################################################


readonly C_CURRENT_BACKUP="important_files_backup"
readonly C_OLD_BACKUP="important_files_backup.old"

C_TMP_BACKUP=$(mktemp -d -p /tmp important_nadeko_files.XXXXXXXXXX)
readonly C_TMP_BACKUP

# shellcheck disable=SC2206
#   $E_FILES_TO_BACK_UP is purposely unquoted to allow word splitting. This will make
#   the contents of $C_FILES_TO_BACK_UP iterable.
readonly C_FILES_TO_BACK_UP=($E_FILES_TO_BACK_UP)


####[ Functions ]#######################################################################


####
# Clean up and exit the script.
#
# PARAMETERS:
#   - $1: exit_code (Required)
#   - $2: use_extra_newline (Optional, Default: false)
#       - Whether to output an extra blank line, to separate the previous output from
#         the output of this function.
#       - Acceptable values:
#           - true
#           - false
clean_exit() {
    local exit_code="$1"
    local use_extra_newline="${2:-false}"
    local cleanup=true

    # Unset the local traps to restore traps set in 'installer-prep'.
    trap - EXIT SIGINT SIGTERM SIGHUP SIGQUIT

    [[ $use_extra_newline == true ]] && echo ""

    ## We modify the exit code to 3, because 'nadeko-main-installer' will not exit if
    ## if the exit code is 3. This exit code is used to indicate that the script exited
    ## due an error, but the main installer should continue.
    case "$exit_code" in
        0)
            cleanup=false
            ;;
        1)
            exit_code=3
            ;;
        130)
            echo -e "\n${E_WARNING}User interrupt detected (SIGINT)"
            exit_code=3
            ;;
        143)
            echo -e "\n${E_WARNING}Termination signal detected (SIGTERM)"
            exit_code=3
            ;;
        129)
            echo -e "\n${E_WARNING}Hangup signal detected (SIGHUP)"
            exit_code=3
            ;;
        131)
            echo -e "\n${E_WARNING}Quit signal detected (SIGQUIT)"
            exit_code=3
            ;;
        *)
            echo -e "\n${E_WARNING}Exiting with code: $exit_code"
            ;;
    esac

    ## This block will only run if the script attempts to exit prematurely (i.e., an
    ## error occurred).
    if [[ $cleanup == true ]]; then
        echo "${E_INFO}Cleaning up..."

        # State before step 1 of finalizing the backup.
        if [[ -d $C_TMP_BACKUP && -d $C_CURRENT_BACKUP && ! -d $C_OLD_BACKUP ]]; then
            rm -rf "$C_TMP_BACKUP" 2>/dev/null
        # State before step 2 of finalizing the backup.
        elif [[ -d $C_TMP_BACKUP && -d $C_OLD_BACKUP && ! -d $C_CURRENT_BACKUP ]]; then
            rm -rf "$C_TMP_BACKUP" 2>/dev/null
            mv "$C_OLD_BACKUP" "$C_CURRENT_BACKUP" \
                || E_STDERR \
                    "Failed to rename '$C_OLD_BACKUP' as '$C_CURRENT_BACKUP'" \
                    "1" \
                    "${E_NOTE}Will exit to prevent data loss"
        # State before step 3 of finalizing the backup.
        elif [[ -d $C_OLD_BACKUP && -d $C_CURRENT_BACKUP && ! -d $C_TMP_BACKUP ]]; then
            rm -rf "$C_OLD_BACKUP" 2>/dev/null
        fi

        # Any state after step 3 doesn't need to be cleaned up.
    fi

    read -rp "${E_NOTE}Press [Enter] to return to the main menu"
    exit "$exit_code"
}


####[ Trapping Logic ]##################################################################


trap 'clean_exit "130" "true"' SIGINT
trap 'clean_exit "143" "true"' SIGTERM
trap 'clean_exit "129" "true"' SIGHUP
trap 'clean_exit "131" "true"' SIGQUIT
trap 'clean_exit "$?" "true"'  EXIT


####[ Main ]############################################################################


echo "${E_NOTE}We will now back up the following files:"
for file in "${C_FILES_TO_BACK_UP[@]}";
    do echo "  ${E_CYAN}|${E_NC}    $file"
done
read -rp "${E_NOTE}Press [Enter] to continue"

echo "${E_INFO}Backing up files into '$C_TMP_BACKUP'..."
for file in "${C_FILES_TO_BACK_UP[@]}"; do
    if [[ -f $file ]]; then
        cp -f "$file" "$C_TMP_BACKUP" || E_STDERR "Failed to back up '$file'" "1"
    else
        echo "${E_WARNING}'$file' could not be found"
    fi
done

if [[ -d $C_CURRENT_BACKUP ]]; then
    echo "${E_INFO}Copying previously backed up files into '$C_TMP_BACKUP'..."
    for file in "$C_CURRENT_BACKUP"/*; do
        # Extract the base filename without the path.
        basefile="${file##*/}"

        if [[ ! $basefile =~ ^.*\.old$ ]]; then
            echo "${E_INFO}    Copying '$file' to '$C_TMP_BACKUP'..."
            cp "$file" "$C_TMP_BACKUP/$basefile.old" \
                || E_STDERR "Failed to copy '$basefile'" "1"
        fi
    done

    echo "${E_INFO}Replacing '$C_CURRENT_BACKUP' with '$C_TMP_BACKUP'..."
    (
        ## DEBUG: The below commented out lines are for debugging purposes.
        set -e
        echo "${E_INFO}    Renaming '$C_CURRENT_BACKUP' to '$C_OLD_BACKUP'..."
        #sleep 10
        mv "$C_CURRENT_BACKUP"/lskdjf "$C_OLD_BACKUP"  # Step 1 of finalizing the backup.
        echo "${E_INFO}    Moving '$C_TMP_BACKUP' to '$C_CURRENT_BACKUP'..."
        #sleep 10
        mv "$C_TMP_BACKUP" "$C_CURRENT_BACKUP"  # Step 2 of finalizing the backup.
        echo "${E_INFO}    Removing '$C_OLD_BACKUP'..."
        #sleep 10
        rm -rf "$C_OLD_BACKUP"  # Step 3 of finalizing the backup.
     ) || E_STDERR "Failed to replace old backup" "1"
else
    echo "${E_INFO}Moving '$C_TMP_BACKUP' to '$C_CURRENT_BACKUP'..."
    mv "$C_TMP_BACKUP" "$C_CURRENT_BACKUP" \
        || E_STDERR "Failed to move '$C_TMP_BACKUP' to '$C_CURRENT_BACKUP'" "1"
fi

echo ""
echo "${E_SUCCESS}Finished backing up files"
clean_exit 0
